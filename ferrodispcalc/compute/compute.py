from ferrodispcalc.compute.pybackend import PyCompute
from ferrodispcalc.compute.cppbackend import CppCompute
from ase import Atoms
import os
import numpy as np
from ferrodispcalc.io.lammps import LAMMPSdump

class Compute:
    def __init__(self, input: str | list[Atoms], 
                 type_map: list[str]=None,
                 prefix: str=None) -> None:
        
        self.traj, self.backend = self.__checkinput(input, type_map)
        self.type_map = type_map
        self.prefix = prefix

    def get_averaged_structure(self, select: slice=None) -> Atoms:
        '''
        Get the averaged structure of the trajectory.

        Parameters:
        ----------
        select: slice
            The slice object. Default is None, which will select the last half of the trajectory.
        
        Returns:
        -------
        averaged_structure: Atoms
            The averaged structure, in ASE Atoms object.
        '''
        select = convert_slice_to_list(self.traj, select)
        self.averaged_structure = self.backend.get_averaged_structure(self.traj, select)
        return self.averaged_structure
    
    def get_displacement(self, nl: np.ndarray, select: slice=None) -> np.ndarray:
        '''
        Get the Polarization displacement of the trajectory.

        Parameters:
        ----------
        nl: np.ndarray
            The neighbor list, generated by `NeighborList.build()`. It is 1-based index. The first column is the center atom index. The rest columns are the neighbor atom indices.
        select: slice
            The slice object. Default is None, which will select the last half of the trajectory.
        '''
        select = convert_slice_to_list(self.traj, select)
        self.displacement = self.backend.get_displacement(self.traj, select, nl)
        return self.displacement
    
    def get_polarization(self, nl: np.ndarray, select: slice=None) -> np.ndarray:
        raise NotImplementedError('get_polarization() is not implemented yet.')
    
    def get_local_lattice():
        raise NotImplementedError('get_local_lattice() is not implemented yet.')
    
    def get_rotation():
        raise NotImplementedError('get_rotation() is not implemented yet.')
    
    def __checkinput(self, input, type_map) -> tuple[list[Atoms] | str, PyCompute | CppCompute]:
        if isinstance(input, list) and all(isinstance(i, (Atoms)) for i in input):
            return input, PyCompute()
        elif isinstance(input, str):
            if not os.path.exists(input):
                raise FileNotFoundError(f'{input} does not exist.')
            if type_map is None:
                raise ValueError('type_map is required for `lmp-dump` file')
            return input, CppCompute()
        else:
            raise ValueError(f'Invalid input type: {type(input)}, only `str`, `list[Atoms]` are supported.')


def convert_slice_to_list(input: str | list, select: slice) -> list[int]:
    '''
    convert slice object to list.
    If select is None, return a list of consecutive integers from nframes/2 to nframes.

    Parameters:
    ----------
    select: slice
        The slice object.

    Returns:
    -------
    list[int]:
        The list of integers, representing the index of selected frames.
    '''
    if select is not None:
        select = list(range(select.start, select.stop, select.step if select.step is not None else 1))
    else:
        if isinstance(input, list):
            nframes = len(input)
        else:
            lmp = LAMMPSdump(input)
            nframes = lmp.get_nframes()
            
        select = list(range(nframes//2, nframes))
    
    return select