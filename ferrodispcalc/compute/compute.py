from ferrodispcalc.compute.pybackend import PyCompute
from ase import Atoms
import numpy as np
from typing import Union
from scipy.spatial.transform import Rotation

class Compute:
    '''Compute class is used to calculate the polarization, displacement, local lattice, octahedral rotation, etc.

    Methods:
    --------
    get_averaged_structure(select: slice=None) -> Atoms
        Get the averaged structure of the trajectory.

    get_displacement(nl: np.ndarray, select: slice=None) -> np.ndarray
        Get the Polarization displacement of the trajectory.
    
    get_polarization(nl: np.ndarray, select: slice=None) -> np.ndarray
        Get the Polarization of the trajectory.
    
    get_local_lattice()
        Get the local lattice of the trajectory.
    
    '''
    def __init__(self, input: Union[str, list[Atoms]], 
                 type_map: list[str]=None,
                 prefix: str=None) -> None:
        
        self.type_map = type_map
        self.prefix = prefix
        self.traj, self.backend = self.__checkinput(input)

    def get_averaged_structure(self) -> Atoms:
        '''
        Get the averaged structure of the trajectory.

        Parameters:
        ----------
        select: slice
            The slice object. Default is None, which will select the last half of the trajectory.
        
        Returns:
        -------
        averaged_structure: Atoms
            The averaged structure, in ASE Atoms object.
        '''
        self.averaged_structure = self.backend.get_averaged_structure()
        return self.averaged_structure
    
    def get_displacement(self, nl: np.ndarray) -> np.ndarray:
        '''
        Get the Polarization displacement of the trajectory.

        Parameters:
        ----------
        nl: np.ndarray
            The neighbor list, generated by `NeighborList.build()`. It is 1-based index. The first column is the center atom index. The rest columns are the neighbor atom indices.
        '''
        self.displacement: np.ndarray = self.backend.get_displacement(nl = nl.copy()) # Make a copy to avoid changing the original neighbor list.
        return self.displacement
    
    def get_polarization(self, nl_ba: np.ndarray, nl_bx: np.ndarray, born_effective_charge: dict[str:list[float]], rotation_mat: Rotation=None) -> np.ndarray:
        '''
        Get the Polarization of the trajectory. Only support ABO3 perovskite structure.

        Parameters:
        ----------
        nl_ba: np.ndarray
            The neighbor list for B-A pair. It is 1-based index. The first column is the center B atom index. The rest columns are the neighbor A atom indices.
        nl_bx: np.ndarray
            Similar to nl_ba, but for B-X pair.
        born_effective_charge: dict[str:list[float]]
            The Born effective charge for each atom type. The key is the atom symbol, and the value is the Born effective charge.
        '''
        self.polarization = self.backend.get_polarization(nl_ba, nl_bx, born_effective_charge, rotation_mat)
        return self.polarization
    
    def get_local_lattice():
        raise NotImplementedError('get_local_lattice() is not implemented yet.')
    
    def get_rotation():
        raise NotImplementedError('get_rotation() is not implemented yet.')
    
    def __checkinput(self, input) -> tuple[Union[list[Atoms], str], PyCompute]:
        if isinstance(input, list) and all(isinstance(i, (Atoms)) for i in input):
            return input, PyCompute(input=input, type_map=self.type_map, prefix=self.prefix)
        else:
            raise ValueError('The input should be a list of ASE Atoms object.')