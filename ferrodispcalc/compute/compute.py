from ferrodispcalc.compute.pybackend import PyCompute
from ase import Atoms
import os
import numpy as np
from ferrodispcalc.io.lammps import LAMMPSdump
from typing import Union

class Compute:
    '''Compute class is used to calculate the polarization, displacement, local lattice, octahedral rotation, etc.

    Methods:
    --------
    get_averaged_structure(select: slice=None) -> Atoms
        Get the averaged structure of the trajectory.

    get_displacement(nl: np.ndarray, select: slice=None) -> np.ndarray
        Get the Polarization displacement of the trajectory.
    
    get_polarization(nl: np.ndarray, select: slice=None) -> np.ndarray
        Get the Polarization of the trajectory.
    
    get_local_lattice()
        Get the local lattice of the trajectory.
    
    '''
    def __init__(self, input: Union[str, list[Atoms]], 
                 type_map: list[str]=None,
                 prefix: str=None) -> None:
        
        self.type_map = type_map
        self.prefix = prefix
        self.traj, self.backend = self.__checkinput(input)

    def get_averaged_structure(self, select: slice=None) -> Atoms:
        '''
        Get the averaged structure of the trajectory.

        Parameters:
        ----------
        select: slice
            The slice object. Default is None, which will select the last half of the trajectory.
        
        Returns:
        -------
        averaged_structure: Atoms
            The averaged structure, in ASE Atoms object.
        '''
        select = convert_slice_to_list(self.traj, select)
        self.averaged_structure = self.backend.get_averaged_structure(select)
        return self.averaged_structure
    
    def get_displacement(self, nl: np.ndarray, select: slice=None) -> np.ndarray:
        '''
        Get the Polarization displacement of the trajectory.

        Parameters:
        ----------
        nl: np.ndarray
            The neighbor list, generated by `NeighborList.build()`. It is 1-based index. The first column is the center atom index. The rest columns are the neighbor atom indices.
        select: slice
            The slice object. Default is None, which will select the last half of the trajectory.
        '''
        select = convert_slice_to_list(self.traj, select)
        self.displacement: np.ndarray = self.backend.get_displacement(select, nl)
        return self.displacement
    
    def get_polarization(self, select: np.ndarray, nl_ba: np.ndarray, nl_bx: np.ndarray, born_effective_charge: dict[str:list[float]]) -> np.ndarray:
        '''
        Get the Polarization of the trajectory. Only support ABO3 perovskite structure.

        Parameters:
        ----------
        select: np.ndarray
            The index of selected frames.
        nl_ba: np.ndarray
            The neighbor list for B-A pair. It is 1-based index. The first column is the center B atom index. The rest columns are the neighbor A atom indices.
        nl_bx: np.ndarray
            Similar to nl_ba, but for B-X pair.
        born_effective_charge: dict[str:list[float]]
            The Born effective charge for each atom type. The key is the atom symbol, and the value is the Born effective charge.
        '''
        select = convert_slice_to_list(self.traj, select)
        self.polarization = self.backend.get_polarization(select, nl_ba, nl_bx, born_effective_charge)
        return self.polarization
    
    def get_local_lattice():
        raise NotImplementedError('get_local_lattice() is not implemented yet.')
    
    def get_rotation():
        raise NotImplementedError('get_rotation() is not implemented yet.')
    
    def __checkinput(self, input) -> tuple[Union[list[Atoms], str], PyCompute]:
        if isinstance(input, list) and all(isinstance(i, (Atoms)) for i in input):
            return input, PyCompute(input=input, type_map=self.type_map, prefix=self.prefix)
        else:
            raise ValueError('The input should be a list of ASE Atoms object.')


def convert_slice_to_list(input: Union[str, list], select: slice) -> list[int]:
    '''
    convert slice object to list.
    If select is None, return a list of consecutive integers from nframes/2 to nframes.

    Parameters:
    ----------
    select: slice
        The slice object.

    Returns:
    -------
    list[int]:
        The list of integers, representing the index of selected frames.
    '''
    if select is not None:
        select = list(range(select.start, select.stop, select.step if select.step is not None else 1))
    else:
        if isinstance(input, list):
            nframes = len(input)
        else:
            lmp = LAMMPSdump(input)
            nframes = lmp.get_nframes()
            
        select = list(range(nframes//2, nframes))
    
    return select