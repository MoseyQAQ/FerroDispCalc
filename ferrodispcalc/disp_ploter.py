'''
ploter.py:
    This module is used to plot the displacement data generated by FDC.

Example:
    from ploter import Ploter
    pl = Ploter('avg_dump.xsf', '1.disp')
    pl.plot('plot')
'''
import matplotlib.pyplot as plt
from ase.geometry import get_layers
from ase.io import read
import numpy as np 
import os
from matplotlib.animation import FuncAnimation, FFMpegWriter

class MultiPloter:
    def __init__(self, atom_file, disp_file, 
                 ele: list=['Ti'], 
                 tolerance: float=1.0, 
                 axis: tuple[tuple]=((1, 0, 0), (0, 1, 0), (0, 0, 1))):
        '''
        Parameters:
            atom_file: str, the atomic structure file, can be any format that ASE can read.
            disp_file: str, the displacement file generated by FDC
            ele, tolerance, axis: see __get_layer function
        '''

        # setup the atom_file and disp_file
        self.atom_file = atom_file
        self.disp_file = disp_file

        '''
        self.tag: np.ndarray, the layer tag of each atom, shape=(n, 3)
        self.size: list[int], the size of the supercell, i.e. [10, 10, 10] means a 10x10x10 supercell
        self.data: np.ndarray, the displacement data, shape=(size[0], size[1], size[2], nframes, 3)
        '''
        self.tag, self.size = self.__get_layer(self.atom_file, ele, tolerance, axis)
        self.natoms = self.tag.shape[0]
        self.data = self.__load_data(self.disp_file, self.tag, self.size, self.natoms)
        print(f"Data loaded successfully, the size of the supercell is {self.size}")
        print(f"Number of atoms: {self.natoms}")
        print(f"Data shape: {self.data.shape}")
    
    @staticmethod
    def __get_layer(atom_file: str, ele: list=['Ti'], 
                    tolerance: float=1.0, 
                    axis: tuple[tuple]=((1, 0, 0), (0, 1, 0), (0, 0, 1))):
        '''
        According to the atomic structure, get the layer tag of each atom.

        Parameters:
            atom_file: str, the atomic structure file, can be any format that ASE can read.
            ele: list[str], the element to be considered (In ABO3 perovskite, Ti as B site cation)
            tolerance: float, the tolerance of the layer (when the distance between two layers < tolerance, 
                            they are considered as the same layer)
            axis: tuple[tuple], the axis of the supercell
        
        Returns:
            tag: np.ndarray, the layer tag of each atom, shape=(n, 3)
            size: list[int], the size of the supercell
        '''
        try:
            atom = read(atom_file)
            index = [idx for idx, i in enumerate(atom) if i.symbol in ele] # select the element we want
            atom = atom[index]
            tag_x, _ = get_layers(atom, axis[0], tolerance=tolerance)
            tag_y, _ = get_layers(atom, axis[1], tolerance=tolerance)
            tag_z, _ = get_layers(atom, axis[2], tolerance=tolerance)

            tag = np.concatenate((tag_x[:, np.newaxis], tag_y[:, np.newaxis], tag_z[:, np.newaxis]), axis=1)
            size = [len(set(tag_x)), len(set(tag_y)), len(set(tag_z))]
            return tag, size
        except Exception as e:
            print(f'Error: {e}')
            exit(1)
        
    @staticmethod
    def __load_data(disp_file: str, tag: np.ndarray, size: list[int], natoms: int):
        '''
        Load the data from "disp_file", and reshape it to the supercell size

        Parameters:
            disp_file: str, the displacement file generated by FDC
            tag: np.ndarray, the layer tag of each atom, shape=(n, 3)
            size: list[int], the size of the supercell
        
        Returns:
            data: np.ndarray, the displacement data, shape=(size[0], size[1], size[2], nframes, 3)
        '''
        try:

            # read the displacement data, and reshape it into (nframes, natoms, 3)
            raw_data = np.loadtxt(disp_file, usecols=(3, 4, 5))
            nframes = len(raw_data) // natoms
            if len(raw_data) % natoms != 0:
                raise ValueError("The number of atoms in the displacement file is not consistent with the atomic structure file")
            raw_data = raw_data.reshape(nframes, natoms, 3)
            
            # reshape the data into (size[0], size[1], size[2], nframes, 3)
            data = np.full([size[0], size[1], size[2], nframes, 3], np.nan)
            for i in range(natoms):
                x = tag[i, 0]
                y = tag[i, 1]
                z = tag[i, 2]
                data[x, y, z] = raw_data[:, i, :]
            return data
        except Exception as e:
            print(f'Error: {e}')
            exit(1)

    @staticmethod
    def __cal_angle(dx, dy):
        '''
        calculate the angle between dx and dy

        Parameters:
            dx, dy: np.ndarray, two components of the displacement
        
        Returns:
            angle: np.ndarray, the angle between dx and dy
        '''
        pp = np.sqrt(dx * dx + dy * dy)
        angle = np.arccos(dx / pp) / np.pi * 180.0
        index = np.where(dy < 0.0)
        angle[index] = 360.0 - angle[index]
        return angle

    def plot(self, file_name: str, plane: str, layer_index: int):
        if plane == 'xy':
            dx = self.data[:, :, layer_index, :, 0] # shape is (size[0], size[1], nframes)
            dy = self.data[:, :, layer_index, :, 1]
            dx.transpose(1, 0, 2)
            dy.transpose(1, 0, 2)
            data = [dx, dy]
            xlabel = "X"
            ylabel = "Y"
            angle = self.__cal_angle(dx, dy)
            fig, ax = plt.subplots(figsize=(1*self.size[0], 1*self.size[1]))
        elif plane == 'xz':
            dx = self.data[:, layer_index, :, :, 0]
            dz = self.data[:, layer_index, :, :, 2]
            dx.transpose(1, 0, 2)
            dz.transpose(1, 0, 2)
            data = [dx, dz]
            xlabel = "X"
            ylabel = "Z"
            angle = self.__cal_angle(dx, dz)
            fig, ax = plt.subplots(figsize=(1*self.size[0], 1*self.size[2]))
        elif plane == 'yz':
            dy = self.data[layer_index, :, :, :, 1]
            dz = self.data[layer_index, :, :, :, 2]
            dy.transpose(1, 0, 2)
            dz.transpose(1, 0, 2)
            xlabel = "Y"
            ylabel = "Z"
            data = [dy, dz]
            angle = self.__cal_angle(dy, dz)
            fig, ax = plt.subplots(figsize=(1*self.size[1], 1*self.size[2]))
        else:
            raise ValueError("The plane should be 'xy', 'xz', or 'yz'")
        
        plt.xlabel(xlabel)
        plt.ylabel(ylabel)

        def update(frame):
            ax.clear()
            ax.quiver(data[0][:, :, frame], data[1][:, :, frame])
            sc = ax.imshow(angle[:, :, frame], cmap='hsv', vmax=360, vmin=0, aspect=1.0, origin='lower')
            plt.title(f"{plane.upper()} plane, {layer_index}th layer, {frame}th frame")
        
        ani = FuncAnimation(fig, update, frames=self.data.shape[3], interval=50)
        writer = FFMpegWriter(fps=20, metadata=dict(artist='Me'), bitrate=1800)
        ani.save(f"{file_name}.mp4", writer=writer)


class Ploter:
    def __init__(self, atom_file, disp_file, 
                 ele: list=['Ti'], 
                 tolerance: float=1.0, 
                 axis: tuple[tuple]=((1, 0, 0), (0, 1, 0), (0, 0, 1))):
        '''
        Parameters:
            atom_file: str, the atomic structure file, can be any format that ASE can read.
            disp_file: str, the displacement file generated by FDC
            ele, tolerance, axis: see __get_layer function
        '''

        # setup the atom_file and disp_file
        self.atom_file = atom_file
        self.disp_file = disp_file

        '''
        self.tag: np.ndarray, the layer tag of each atom, shape=(n, 3)
        self.size: list[int], the size of the supercell, i.e. [10, 10, 10] means a 10x10x10 supercell
        self.data: np.ndarray, the displacement data, shape=(size[0], size[1], size[2], 3)
        '''
        self.tag, self.size = self.__get_layer(self.atom_file, ele, tolerance, axis)
        self.data = self.__load_data(self.disp_file, self.tag, self.size)
        print(f"Data loaded successfully, the size of the supercell is {self.size}")

    @staticmethod
    def __get_layer(atom_file: str, ele: list=['Ti'], 
                    tolerance: float=1.0, 
                    axis: tuple[tuple]=((1, 0, 0), (0, 1, 0), (0, 0, 1))):
        '''
        According to the atomic structure, get the layer tag of each atom.

        Parameters:
            atom_file: str, the atomic structure file, can be any format that ASE can read.
            ele: list[str], the element to be considered (In ABO3 perovskite, Ti as B site cation)
            tolerance: float, the tolerance of the layer (when the distance between two layers < tolerance, 
                            they are considered as the same layer)
            axis: tuple[tuple], the axis of the supercell
        
        Returns:
            tag: np.ndarray, the layer tag of each atom, shape=(n, 3)
            size: list[int], the size of the supercell
        '''
        try:
            atom = read(atom_file)
            index = [idx for idx, i in enumerate(atom) if i.symbol in ele] # select the element we want
            atom = atom[index]
            tag_x, _ = get_layers(atom, axis[0], tolerance=tolerance)
            tag_y, _ = get_layers(atom, axis[1], tolerance=tolerance)
            tag_z, _ = get_layers(atom, axis[2], tolerance=tolerance)

            tag = np.concatenate((tag_x[:, np.newaxis], tag_y[:, np.newaxis], tag_z[:, np.newaxis]), axis=1)
            size = [len(set(tag_x)), len(set(tag_y)), len(set(tag_z))]
            return tag, size
        except Exception as e:
            print(f'Error: {e}')
            exit(1)

    @staticmethod
    def __cal_angle(dx, dy):
        '''
        calculate the angle between dx and dy

        Parameters:
            dx, dy: np.ndarray, two components of the displacement
        
        Returns:
            angle: np.ndarray, the angle between dx and dy
        '''
        pp = np.sqrt(dx * dx + dy * dy)
        angle = np.arccos(dx / pp) / np.pi * 180.0
        index = np.where(dy < 0.0)
        angle[index] = 360.0 - angle[index]
        return angle

    @staticmethod
    def __load_data(disp_file: str, tag: np.ndarray, size: list[int]):
        '''
        Load the data from "disp_file", and reshape it to the supercell size

        Parameters:
            disp_file: str, the displacement file generated by FDC
            tag: np.ndarray, the layer tag of each atom, shape=(n, 3)
            size: list[int], the size of the supercell
        
        Returns:
            data: np.ndarray, the displacement data, shape=(size[0], size[1], size[2], 3)
        '''
        try:
            raw_data = np.loadtxt(disp_file, usecols=(3, 4, 5))
            data = np.full([size[0], size[1], size[2], 3], np.nan)
            for i in range(len(raw_data)):
                x = tag[i, 0]
                y = tag[i, 1]
                z = tag[i, 2]
                data[x, y, z] = raw_data[i]
            return data
        except Exception as e:
            print(f'Error: {e}')
            exit(1)
        
    def plot(self, save_dir: str):
        '''
        Plot the displacement data
        
        Parameters:
            save_dir: str, the directory to save the plot
        '''
        if not os.path.exists(save_dir):
            os.makedirs(save_dir)
        
        # plot xy 
        for z_index in range(self.size[2]):
            print(f"Plotting XY plane, {z_index}th layer")
            fig, ax = plt.subplots(figsize=(1*self.size[0], 1*self.size[1]))
            dx = self.data[:, :, z_index, 0].T
            dy = self.data[:, :, z_index, 1].T
            angle = self.__cal_angle(dx, dy)
            ax.quiver(dx, dy)
            sc = ax.imshow(angle, cmap='hsv', vmax=360, vmin=0, aspect=1.0, origin='lower')
            plt.title(f"XY plane, {z_index}th layer")
            plt.xlabel("[100]")
            plt.ylabel("[010]")
            plt.savefig(f"{save_dir}/XY_{z_index}.png", bbox_inches='tight', dpi=300)
            plt.close()
        
        # plot xz
        for y_index in range(self.size[1]):
            print(f"Plotting XZ plane, {y_index}th layer")
            fig, ax = plt.subplots(figsize=(1*self.size[0], 1*self.size[2]))
            dx = self.data[:, y_index, :, 0].T
            dz = self.data[:, y_index, :, 2].T
            angle = self.__cal_angle(dx, dz)
            ax.quiver(dx, dz)
            sc = ax.imshow(angle, cmap='hsv', vmax=360, vmin=0, aspect=1.0, origin='lower')
            plt.title(f"XZ plane, {y_index}th layer")
            plt.xlabel("[100]")
            plt.ylabel("[001]")
            plt.savefig(f"{save_dir}/XZ_{y_index}.png", bbox_inches='tight', dpi=300)
            plt.close()

        # plot yz 
        for x_index in range(self.size[0]):
            print(f"Plotting YZ plane, {x_index}th layer")
            fig, ax = plt.subplots(figsize=(1*self.size[1], 1*self.size[2]))
            dy = self.data[x_index, :, :, 1].T
            dz = self.data[x_index, :, :, 2].T
            angle = self.__cal_angle(dy, dz)
            ax.quiver(dy, dz)
            sc = ax.imshow(angle, cmap='hsv', vmax=360, vmin=0, aspect=1.0, origin='lower')
            plt.title(f"YZ plane, {x_index}th layer")
            plt.xlabel("[010]")
            plt.ylabel("[001]")
            plt.savefig(f"{save_dir}/YZ_{x_index}.png", bbox_inches='tight', dpi=300)
            plt.close()